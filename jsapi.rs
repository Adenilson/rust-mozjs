/* automatically generated by rust-bindgen */

use libc::*;
use jsfriendapi::JSJitInfo;
use jsval::JSVal;

pub enum JSString {}
pub enum JSFlatString {}
pub enum JSObject {}
pub enum JSScript {}
pub enum JSFunction {}
pub enum JSContext {}
pub enum JSRuntime {}
pub enum JSIdArray {}
pub enum JSExceptionState {}
pub enum JSStructuredCloneReader {}
pub enum JSStructuredCloneWriter {}
pub enum JSCompartment {}
pub enum JSCrossCompartmentCall {}
pub type JSBool = c_int;
pub type jschar = uint16_t;
pub type jsid = ptrdiff_t;
pub type JSCallOnceType = JSBool;
pub type JSInitCallback = *u8;

pub type JSProtoKey = c_uint;
pub static JSProto_LIMIT: JSProtoKey = 41;

#[repr(u32)]
pub enum JSVersion {
    JSVERSION_DEFAULT = 0,
    JSVERSION_LATEST  = 185
}

#[repr(u32)]
pub enum JSIterateOp {
    JSENUMERATE_INIT = 0,
    JSENUMERATE_INIT_ALL = 1,
    JSENUMERATE_NEXT = 2,
    JSENUMERATE_DESTROY = 3,
}

#[repr(u32)]
pub enum JSType {
    JSTYPE_VOID,                /* undefined */
    JSTYPE_OBJECT,              /* object */
    JSTYPE_FUNCTION,            /* function */
    JSTYPE_STRING,              /* string */
    JSTYPE_NUMBER,              /* number */
    JSTYPE_BOOLEAN,             /* boolean */
    JSTYPE_NULL,                /* null */
    JSTYPE_XML,                 /* xml object */
    JSTYPE_LIMIT
}

#[repr(u32)]
pub enum JSAccessMode {
    JSACC_PROTO  = 0,
    JSACC_WATCH  = 3,
    JSACC_READ   = 4,
    JSACC_WRITE  = 8,
    JSACC_LIMIT
}

#[repr(u32)]
pub enum JSGCTraceKind {
    JSTRACE_OBJECT = 0,
    JSTRACE_STRING = 1,
    JSTRACE_SCRIPT = 2,
}

pub static JS_DEFAULT_ZEAL_FREQ: u32 = 100;

pub type moz_static_assert6 = [c_int, ..1u];
pub struct JSHandleObject {
    pub unnamed_field1: *mut *mut JSObject,
}
pub struct JSHandleValue {
    pub unnamed_field1: JSVal,
}
pub struct JSHandleString {
    pub unnamed_field1: *mut *mut JSString,
}
pub struct JSMutableHandleObject {
    pub unnamed_field1: *mut *mut JSObject,
}
pub struct JSHandleId {
    pub unnamed_field1: *mut jsid,
}
pub struct JSMutableHandleValue {
    pub unnamed_field1: *mut JSVal,
}
pub type JSRawObject = *mut JSObject;
pub type JSPropertyOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject, arg3: JSHandleId, arg4: JSMutableHandleValue)
                              -> JSBool>;
pub type JSStrictPropertyOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject, arg3: JSHandleId, arg4: JSBool, arg5: JSMutableHandleValue) -> JSBool>;
pub type JSNewEnumerateOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject, arg3: JSIterateOp, arg4: *mut JSVal, arg5: *mut jsid) -> JSBool>;
pub type JSEnumerateOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject)
                              -> JSBool>;
pub type JSResolveOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject, arg3: JSHandleId) -> JSBool>;
pub type JSNewResolveOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject, arg3: JSHandleId, arg4: c_uint, arg5: JSMutableHandleObject) -> JSBool>;
pub type JSConvertOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject, arg3: JSType, arg4: JSMutableHandleValue)
                              -> JSBool>;
pub type JSTypeOfOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject)
                              -> JSType>;
pub struct JSFreeOp {
    pub runtime: *mut JSRuntime,
}
pub type JSFinalizeOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSFreeOp, arg2: *mut JSObject)>;
pub struct JSStringFinalizer {
    pub finalize:   Option<unsafe extern "C" fn
                                            (arg1: *JSStringFinalizer, arg2: *mut jschar)>,
}
pub type JSCheckAccessOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject, arg3: JSHandleId, arg4: JSAccessMode, arg5: *mut JSVal) -> JSBool>;
pub type JSHasInstanceOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject, arg3: *JSVal, arg4: *mut JSBool) -> JSBool>;
pub type JSTraceOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSTracer, arg2: *mut JSObject)>;
pub type JSTraceNamePrinter =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSTracer, arg2: *mut c_char, arg3: size_t)>;
pub type JSEqualityOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: JSHandleObject, arg3: *JSVal, arg4: *mut JSBool) -> JSBool>;
pub type JSNative =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: c_uint, arg3: *mut JSVal) -> JSBool>;
pub type Enum_JSContextOp = c_uint;
pub static JSCONTEXT_NEW: c_uint = 0;
pub static JSCONTEXT_DESTROY: c_uint = 1;
pub type JSContextOp = Enum_JSContextOp;
pub type JSContextCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: c_uint)
                              -> JSBool>;
pub type Enum_JSGCStatus = c_uint;
pub static JSGC_BEGIN: c_uint = 0;
pub static JSGC_END: c_uint = 1;
pub type JSGCStatus = Enum_JSGCStatus;
pub type JSGCCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSRuntime, arg2: JSGCStatus)>;
pub type Enum_JSFinalizeStatus = c_uint;
pub static JSFINALIZE_START: c_uint = 0;
pub static JSFINALIZE_END: c_uint = 1;
pub type JSFinalizeStatus = Enum_JSFinalizeStatus;
pub type JSFinalizeCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSFreeOp, arg2: JSFinalizeStatus, arg3: JSBool)>;
pub type JSTraceDataOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSTracer, arg2: *mut c_void)>;
pub type JSOperationCallback =
                   Option<unsafe extern "C" fn(arg1: *mut JSContext) -> JSBool>;
pub type JSErrorReporter =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *c_char, arg3: *mut JSErrorReport)>;
pub type Enum_JSExnType = c_int;
pub static JSEXN_NONE: c_int = -1;
pub static JSEXN_ERR: c_int = 0;
pub static JSEXN_INTERNALERR: c_int = 1;
pub static JSEXN_EVALERR: c_int = 2;
pub static JSEXN_RANGEERR: c_int = 3;
pub static JSEXN_REFERENCEERR: c_int = 4;
pub static JSEXN_SYNTAXERR: c_int = 5;
pub static JSEXN_TYPEERR: c_int = 6;
pub static JSEXN_URIERR: c_int = 7;
pub static JSEXN_LIMIT: c_int = 8;
pub type JSExnType = Enum_JSExnType;
pub struct JSErrorFormatString {
    pub format: *c_char,
    pub argCount: uint16_t,
    pub exnType: int16_t,
}
pub type JSErrorCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut c_void, arg2: *c_char, arg3: c_uint)
                              -> *JSErrorFormatString>;
pub type JSLocaleToUpperCase =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *mut JSString, arg3: *mut JSVal) -> JSBool>;
pub type JSLocaleToLowerCase =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *mut JSString, arg3: *mut JSVal) -> JSBool>;
pub type JSLocaleCompare =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *mut JSString, arg3: *mut JSString, arg4: *mut JSVal)
                              -> JSBool>;
pub type JSLocaleToUnicode =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *c_char, arg3: *mut JSVal) -> JSBool>;
pub type JSDestroyPrincipalsOp =
                   Option<unsafe extern "C" fn(arg1: *mut JSPrincipals)>;
pub type JSSubsumePrincipalsOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSPrincipals, arg2: *mut JSPrincipals) -> JSBool>;
pub type JSObjectPrincipalsFinder =
                   Option<unsafe extern "C" fn(arg1: *mut JSObject)
                              -> *mut JSPrincipals>;
pub type JSCSPEvalChecker =
                   Option<unsafe extern "C" fn(arg1: *mut JSContext) -> JSBool>;
pub type JSWrapObjectCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *mut JSObject, arg3: *mut JSObject, arg4: *mut JSObject, arg5: c_uint) -> *mut JSObject>;
pub type JSPreWrapCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *mut JSObject, arg3: *mut JSObject, arg4: c_uint)
                              -> *mut JSObject>;
pub type JSSameCompartmentWrapObjectCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *mut JSObject)
                              -> *mut JSObject>;
pub type JSDestroyCompartmentCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSFreeOp, arg2: *mut JSCompartment)>;
pub type JSCompartmentNameCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSRuntime, arg2: *mut JSCompartment, arg3: *mut c_char, arg4: size_t)>;
pub type ReadStructuredCloneOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *mut JSStructuredCloneReader, arg3: uint32_t, arg4: uint32_t, arg5: *mut c_void) -> *mut JSObject>;
pub type WriteStructuredCloneOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: *mut JSStructuredCloneWriter, arg3: *mut JSObject, arg4: *mut c_void)
                              -> JSBool>;
pub type StructuredCloneErrorOp =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSContext, arg2: uint32_t)>;
pub type JSIterateCompartmentCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSRuntime, arg2: *mut c_void, arg3: *mut JSCompartment)>;
pub type JSEnumerateDiagnosticMemoryCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut c_void, arg2: size_t)
                              -> JSBool>;
pub type Enum_JSGCRootType = c_uint;
pub static JS_GC_ROOT_VALUE_PTR: c_uint = 0;
pub static JS_GC_ROOT_GCTHING_PTR: c_uint = 1;
pub type JSGCRootType = Enum_JSGCRootType;
pub type JSGCRootMapFun =
                   Option<unsafe extern "C" fn
                              (arg1: *mut c_void, arg2: JSGCRootType, arg3: *c_char, arg4: *mut c_void) -> c_int>;
pub type JSTraceCallback =
                   Option<unsafe extern "C" fn
                              (arg1: *mut JSTracer, arg2: *mut *mut c_void, arg3: JSGCTraceKind)>;
pub struct JSTracer {
    pub runtime: *mut JSRuntime,
    pub callback: JSTraceCallback,
    pub debugPrinter: JSTraceNamePrinter,
    pub debugPrintArg: *c_void,
    pub debugPrintIndex: size_t,
    pub eagerlyTraceWeakMaps: JSBool,
    pub realLocation: *mut c_void,
}
pub type Enum_JSGCParamKey = c_uint;
pub static JSGC_MAX_BYTES: c_uint = 0;
pub static JSGC_MAX_MALLOC_BYTES: c_uint = 1;
pub static JSGC_BYTES: c_uint = 3;
pub static JSGC_NUMBER: c_uint = 4;
pub static JSGC_MAX_CODE_CACHE_BYTES: c_uint = 5;
pub static JSGC_MODE: c_uint = 6;
pub static JSGC_UNUSED_CHUNKS: c_uint = 7;
pub static JSGC_TOTAL_CHUNKS: c_uint = 8;
pub static JSGC_SLICE_TIME_BUDGET: c_uint = 9;
pub static JSGC_MARK_STACK_LIMIT: c_uint = 10;
pub static JSGC_HIGH_FREQUENCY_TIME_LIMIT: c_uint = 11;
pub static JSGC_HIGH_FREQUENCY_LOW_LIMIT: c_uint = 12;
pub static JSGC_HIGH_FREQUENCY_HIGH_LIMIT: c_uint = 13;
pub static JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX: c_uint = 14;
pub static JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN: c_uint = 15;
pub static JSGC_LOW_FREQUENCY_HEAP_GROWTH: c_uint = 16;
pub static JSGC_DYNAMIC_HEAP_GROWTH: c_uint = 17;
pub static JSGC_DYNAMIC_MARK_SLICE: c_uint = 18;
pub static JSGC_ANALYSIS_PURGE_TRIGGER: c_uint = 19;
pub type JSGCParamKey = Enum_JSGCParamKey;
pub type Enum_JSGCMode = c_uint;
pub static JSGC_MODE_GLOBAL: c_uint = 0;
pub static JSGC_MODE_COMPARTMENT: c_uint = 1;
pub static JSGC_MODE_INCREMENTAL: c_uint = 2;
pub type JSGCMode = Enum_JSGCMode;
pub type JSClassInternal =                Option<extern "C" fn()>;
pub struct JSClass {
    pub name: *c_char,
    pub flags: uint32_t,
    pub addProperty: JSPropertyOp,
    pub delProperty: JSPropertyOp,
    pub getProperty: JSPropertyOp,
    pub setProperty: JSStrictPropertyOp,
    pub enumerate: JSEnumerateOp,
    pub resolve: JSResolveOp,
    pub convert: JSConvertOp,
    pub finalize: JSFinalizeOp,
    pub checkAccess: JSCheckAccessOp,
    pub call: JSNative,
    pub hasInstance: JSHasInstanceOp,
    pub construct: JSNative,
    pub trace: JSTraceOp,
    pub reserved: [*mut c_void, ..40u],
}
pub struct JSConstDoubleSpec {
    pub dval: c_double,
    pub name: *c_char,
    pub flags: uint8_t,
    pub spare: [uint8_t, ..3u],
}
pub struct JSStrictPropertyOpWrapper {
    pub op: JSNative,
    pub info: *JSJitInfo,
}
pub struct JSPropertyOpWrapper {
    pub op: JSNative,
    pub info: *JSJitInfo,
}
pub struct JSNativeWrapper {
    pub op: JSNative,
    pub info: *JSJitInfo,
}
pub struct JSPropertySpec {
    pub name: *c_char,
    pub tinyid: int8_t,
    pub flags: uint8_t,
    pub getter: JSPropertyOpWrapper,
    pub setter: JSStrictPropertyOpWrapper,
}
pub struct JSFunctionSpec {
    pub name: *c_char,
    pub call: JSNativeWrapper,
    pub nargs: uint16_t,
    pub flags: uint16_t,
    pub selfHostedName: *c_char,
}
pub struct JSPropertyDescriptor {
    pub obj: *mut JSObject,
    pub attrs: c_uint,
    pub shortid: c_uint,
    pub getter: JSPropertyOp,
    pub setter: JSStrictPropertyOp,
    pub value: JSVal,
}
pub struct JSPrincipals {
    pub refcount: c_int,
}
pub struct JSSecurityCallbacks {
    pub checkObjectAccess: JSCheckAccessOp,
    pub subsumePrincipals: JSSubsumePrincipalsOp,
    pub findObjectPrincipals: JSObjectPrincipalsFinder,
    pub contentSecurityPolicyAllows: JSCSPEvalChecker,
}
pub type Enum_JSExecPart = c_uint;
pub static JSEXEC_PROLOG: c_uint = 0;
pub static JSEXEC_MAIN: c_uint = 1;
pub type JSExecPart = Enum_JSExecPart;
pub type JSONWriteCallback =
                   Option<extern "C" fn
                              (arg1: *jschar, arg2: uint32_t, arg3: *mut c_void) -> JSBool>;
pub struct JSStructuredCloneCallbacks {
    pub read: ReadStructuredCloneOp,
    pub write: WriteStructuredCloneOp,
    pub reportError: StructuredCloneErrorOp,
}
pub struct JSLocaleCallbacks {
    pub localeToUpperCase: JSLocaleToUpperCase,
    pub localeToLowerCase: JSLocaleToLowerCase,
    pub localeCompare: JSLocaleCompare,
    pub localeToUnicode: JSLocaleToUnicode,
    pub localeGetErrorMessage: JSErrorCallback,
}
pub struct JSErrorReport {
    pub filename: *c_char,
    pub originPrincipals: *mut JSPrincipals,
    pub lineno: c_uint,
    pub linebuf: *c_char,
    pub tokenptr: *c_char,
    pub uclinebuf: *jschar,
    pub uctokenptr: *jschar,
    pub flags: c_uint,
    pub errorNumber: c_uint,
    pub ucmessage: *jschar,
    pub messageArgs: *mut *jschar,
    pub exnType: int16_t,
    pub column: c_uint,
}
extern "C" {
pub fn JS_CreateHandleObject(cx: *mut JSContext, obj: *mut JSObject, phandle: *mut JSHandleObject) -> JSBool;

pub fn JS_DestroyHandleObject(cx: *mut JSContext, handle: JSHandleObject);

pub fn JS_CreateMutableHandleObject(cx: *mut JSContext, obj: *mut JSObject, phandle: *mut JSMutableHandleObject) -> JSBool;

pub fn JS_DestroyMutableHandleObject(cx: *mut JSContext, handle: JSMutableHandleObject);

pub fn JS_CreateHandleId(cx: *mut JSContext, id: jsid, phandle: *mut JSHandleId) -> JSBool;

pub fn JS_DestroyHandleId(cx: *mut JSContext, handle: JSHandleId);

pub fn JS_StringHasBeenInterned(cx: *mut JSContext, str: *mut JSString) -> JSBool;

pub fn INTERNED_STRING_TO_JSID(cx: *mut JSContext, str: *mut JSString) -> jsid;

pub fn JS_CallOnce(_once: *mut JSCallOnceType, func: JSInitCallback) -> JSBool;

pub fn JS_Now() -> int64_t;

pub fn JS_GetNaNValue(cx: *mut JSContext) -> JSVal;

pub fn JS_GetNegativeInfinityValue(cx: *mut JSContext) -> JSVal;

pub fn JS_GetPositiveInfinityValue(cx: *mut JSContext) -> JSVal;

pub fn JS_GetEmptyStringValue(cx: *mut JSContext) -> JSVal;

pub fn JS_GetEmptyString(rt: *mut JSRuntime) -> *mut JSString;

pub fn JS_ConvertArguments(cx: *mut JSContext, argc: c_uint, argv: *mut JSVal, format: *c_char, ...) -> JSBool;

pub fn JS_ConvertValue(cx: *mut JSContext, v: JSVal, _type: JSType, vp: *mut JSVal) -> JSBool;

pub fn JS_ValueToObject(cx: *mut JSContext, v: JSVal, objp: *mut *mut JSObject) -> JSBool;

pub fn JS_ValueToFunction(cx: *mut JSContext, v: JSVal) -> *mut JSFunction;

pub fn JS_ValueToConstructor(cx: *mut JSContext, v: JSVal) -> *mut JSFunction;

pub fn JS_ValueToString(cx: *mut JSContext, v: JSVal) -> *mut JSString;

pub fn JS_ValueToSource(cx: *mut JSContext, v: JSVal) -> *mut JSString;

pub fn JS_ValueToNumber(cx: *mut JSContext, v: JSVal, dp: *mut c_double) -> JSBool;

pub fn JS_DoubleIsInt32(d: c_double, ip: *mut int32_t) -> JSBool;

pub fn JS_DoubleToInt32(d: c_double) -> int32_t;

pub fn JS_DoubleToUint32(d: c_double) -> uint32_t;

pub fn JS_ValueToECMAInt32(cx: *mut JSContext, v: JSVal, ip: *mut int32_t) -> JSBool;

pub fn JS_ValueToInt64(cx: *mut JSContext, v: JSVal, ip: *mut int64_t) -> JSBool;

pub fn JS_ValueToUint64(cx: *mut JSContext, v: JSVal, ip: *mut uint64_t) -> JSBool;

pub fn JS_ValueToECMAUint32(cx: *mut JSContext, v: JSVal, ip: *mut uint32_t) -> JSBool;

pub fn JS_ValueToInt32(cx: *mut JSContext, v: JSVal, ip: *mut int32_t) -> JSBool;

pub fn JS_ValueToUint16(cx: *mut JSContext, v: JSVal, ip: *mut uint16_t) -> JSBool;

pub fn JS_ValueToBoolean(cx: *mut JSContext, v: JSVal, bp: *mut JSBool) -> JSBool;

pub fn JS_TypeOfValue(cx: *mut JSContext, v: JSVal) -> JSType;

pub fn JS_GetTypeName(cx: *mut JSContext, _type: JSType) -> *c_char;

pub fn JS_StrictlyEqual(cx: *mut JSContext, v1: JSVal, v2: JSVal, equal: *mut JSBool) -> JSBool;

pub fn JS_LooselyEqual(cx: *mut JSContext, v1: JSVal, v2: JSVal, equal: *mut JSBool) -> JSBool;

pub fn JS_SameValue(cx: *mut JSContext, v1: JSVal, v2: JSVal, same: *mut JSBool) -> JSBool;

pub fn JS_IsBuiltinEvalFunction(fun: *mut JSFunction) -> JSBool;

pub fn JS_IsBuiltinFunctionConstructor(fun: *mut JSFunction) -> JSBool;

pub fn JS_Init(maxbytes: uint32_t) -> *mut JSRuntime;

pub fn JS_Finish(rt: *mut JSRuntime);

pub fn JS_ShutDown();

pub fn JS_GetRuntimePrivate(rt: *mut JSRuntime) -> *mut c_void;

pub fn JS_GetRuntime(cx: *mut JSContext) -> *mut JSRuntime;

pub fn JS_SetRuntimePrivate(rt: *mut JSRuntime, data: *mut c_void);

pub fn JS_BeginRequest(cx: *mut JSContext);

pub fn JS_EndRequest(cx: *mut JSContext);

pub fn JS_YieldRequest(cx: *mut JSContext);

pub fn JS_SuspendRequest(cx: *mut JSContext) -> c_uint;

pub fn JS_ResumeRequest(cx: *mut JSContext, saveDepth: c_uint);

pub fn JS_IsInRequest(rt: *mut JSRuntime) -> JSBool;

pub fn JS_IsInSuspendedRequest(rt: *mut JSRuntime) -> JSBool;

pub fn JS_SetContextCallback(rt: *mut JSRuntime, cxCallback: JSContextCallback) -> JSContextCallback;

pub fn JS_NewContext(rt: *mut JSRuntime, stackChunkSize: size_t) -> *mut JSContext;

pub fn JS_DestroyContext(cx: *mut JSContext);

pub fn JS_DestroyContextNoGC(cx: *mut JSContext);

pub fn JS_GetContextPrivate(cx: *mut JSContext) -> *mut c_void;

pub fn JS_SetContextPrivate(cx: *mut JSContext, data: *mut c_void);

pub fn JS_GetSecondContextPrivate(cx: *mut JSContext) -> *mut c_void;

pub fn JS_SetSecondContextPrivate(cx: *mut JSContext, data: *mut c_void);

pub fn JS_ContextIterator(rt: *mut JSRuntime, iterp: *mut *mut JSContext) -> *mut JSContext;

pub fn JS_GetVersion(cx: *mut JSContext) -> JSVersion;

pub fn JS_SetVersion(cx: *mut JSContext, version: JSVersion) -> JSVersion;

pub fn JS_VersionToString(version: JSVersion) -> *c_char;

pub fn JS_StringToVersion(string: *c_char) -> JSVersion;

pub fn JS_GetOptions(cx: *mut JSContext) -> uint32_t;

pub fn JS_SetOptions(cx: *mut JSContext, options: uint32_t) -> uint32_t;

pub fn JS_ToggleOptions(cx: *mut JSContext, options: uint32_t) -> uint32_t;

pub fn JS_SetJitHardening(rt: *mut JSRuntime, enabled: JSBool);

pub fn JS_GetImplementationVersion() -> *c_char;

pub fn JS_SetDestroyCompartmentCallback(rt: *mut JSRuntime, callback: JSDestroyCompartmentCallback);

pub fn JS_SetCompartmentNameCallback(rt: *mut JSRuntime, callback: JSCompartmentNameCallback);

pub fn JS_SetWrapObjectCallbacks(rt: *mut JSRuntime, callback: JSWrapObjectCallback, sccallback: JSSameCompartmentWrapObjectCallback, precallback: JSPreWrapCallback) -> JSWrapObjectCallback;

pub fn JS_EnterCrossCompartmentCall(cx: *mut JSContext, target: JSRawObject) -> *mut JSCrossCompartmentCall;

pub fn JS_LeaveCrossCompartmentCall(call: *mut JSCrossCompartmentCall);

pub fn JS_SetCompartmentPrivate(compartment: *mut JSCompartment, data: *mut c_void);

pub fn JS_GetCompartmentPrivate(compartment: *mut JSCompartment) -> *mut c_void;

pub fn JS_WrapObject(cx: *mut JSContext, objp: *mut *mut JSObject) -> JSBool;

pub fn JS_WrapValue(cx: *mut JSContext, vp: *mut JSVal) -> JSBool;

pub fn JS_TransplantObject(cx: *mut JSContext, origobj: *mut JSObject, target: *mut JSObject) -> *mut JSObject;

pub fn js_TransplantObjectWithWrapper(cx: *mut JSContext, origobj: *mut JSObject, origwrapper: *mut JSObject, targetobj: *mut JSObject, targetwrapper: *mut JSObject) -> *mut JSObject;

pub fn JS_RefreshCrossCompartmentWrappers(cx: *mut JSContext, ob: *mut JSObject) -> JSBool;

pub fn JS_IterateCompartments(rt: *mut JSRuntime, data: *mut c_void, compartmentCallback: JSIterateCompartmentCallback);

pub fn JS_GetGlobalObject(cx: *mut JSContext) -> *mut JSObject;

pub fn JS_SetGlobalObject(cx: *mut JSContext, obj: JSRawObject);

pub fn JS_InitStandardClasses(cx: *mut JSContext, obj: *mut JSObject) -> JSBool;

pub fn JS_ResolveStandardClass(cx: *mut JSContext, obj: *mut JSObject, id: jsid, resolved: *mut JSBool) -> JSBool;

pub fn JS_EnumerateStandardClasses(cx: *mut JSContext, obj: *mut JSObject) -> JSBool;

pub fn JS_EnumerateResolvedStandardClasses(cx: *mut JSContext, obj: *mut JSObject, ida: *mut JSIdArray) -> *mut JSIdArray;

pub fn JS_GetClassObject(cx: *mut JSContext, obj: JSRawObject, key: JSProtoKey, objp: *mut *mut JSObject) -> JSBool;

pub fn JS_GetClassPrototype(cx: *mut JSContext, key: JSProtoKey, objp: *mut *mut JSObject) -> JSBool;

pub fn JS_IdentifyClassPrototype(cx: *mut JSContext, obj: *mut JSObject) -> JSProtoKey;

pub fn JS_GetFunctionPrototype(cx: *mut JSContext, forObj: JSRawObject) -> *mut JSObject;

pub fn JS_GetObjectPrototype(cx: *mut JSContext, forObj: JSRawObject) -> *mut JSObject;

pub fn JS_GetGlobalForObject(cx: *mut JSContext, obj: JSRawObject) -> *mut JSObject;

pub fn JS_GetGlobalForCompartmentOrNull(cx: *mut JSContext, c: *mut JSCompartment) -> *mut JSObject;

pub fn JS_GetGlobalForScopeChain(cx: *mut JSContext) -> *mut JSObject;

pub fn JS_GetScriptedGlobal(cx: *mut JSContext) -> *mut JSObject;

pub fn JS_InitReflect(cx: *mut JSContext, global: *mut JSObject) -> *mut JSObject;

pub fn JS_EnumerateDiagnosticMemoryRegions(callback: JSEnumerateDiagnosticMemoryCallback);

pub fn JS_ComputeThis(cx: *mut JSContext, vp: *mut JSVal) -> JSVal;

pub fn JS_MallocInCompartment(comp: *mut JSCompartment, nbytes: size_t);

pub fn JS_FreeInCompartment(comp: *mut JSCompartment, nbytes: size_t);

pub fn JS_malloc(cx: *mut JSContext, nbytes: size_t) -> *mut c_void;

pub fn JS_realloc(cx: *mut JSContext, p: *mut c_void, nbytes: size_t) -> *mut c_void;

pub fn JS_free(cx: *mut JSContext, p: *mut c_void);

pub fn JS_freeop(fop: *mut JSFreeOp, p: *mut c_void);

pub fn JS_GetDefaultFreeOp(rt: *mut JSRuntime) -> *mut JSFreeOp;

pub fn JS_updateMallocCounter(cx: *mut JSContext, nbytes: size_t);

pub fn JS_strdup(cx: *mut JSContext, s: *c_char) -> *mut c_char;

pub fn JS_AddValueRoot(cx: *mut JSContext, vp: *mut JSVal) -> JSBool;

pub fn JS_AddStringRoot(cx: *mut JSContext, rp: *mut *mut JSString) -> JSBool;

pub fn JS_AddObjectRoot(cx: *mut JSContext, rp: *mut *mut JSObject) -> JSBool;

pub fn JS_AddGCThingRoot(cx: *mut JSContext, rp: *mut *mut c_void) -> JSBool;

pub fn JS_AddNamedValueRoot(cx: *mut JSContext, vp: *mut JSVal, name: *c_char) -> JSBool;

pub fn JS_AddNamedStringRoot(cx: *mut JSContext, rp: *mut *mut JSString, name: *c_char) -> JSBool;

pub fn JS_AddNamedObjectRoot(cx: *mut JSContext, rp: *mut *mut JSObject, name: *c_char) -> JSBool;

pub fn JS_AddNamedScriptRoot(cx: *mut JSContext, rp: *mut *mut JSScript, name: *c_char) -> JSBool;

pub fn JS_AddNamedGCThingRoot(cx: *mut JSContext, rp: *mut *mut c_void, name: *c_char) -> JSBool;

pub fn JS_RemoveValueRoot(cx: *mut JSContext, vp: *mut JSVal);

pub fn JS_RemoveStringRoot(cx: *mut JSContext, rp: *mut *mut JSString);

pub fn JS_RemoveObjectRoot(cx: *mut JSContext, rp: *mut *mut JSObject);

pub fn JS_RemoveScriptRoot(cx: *mut JSContext, rp: *mut *mut JSScript);

pub fn JS_RemoveGCThingRoot(cx: *mut JSContext, rp: *mut *mut c_void);

pub fn JS_RemoveValueRootRT(rt: *mut JSRuntime, vp: *mut JSVal);

pub fn JS_RemoveStringRootRT(rt: *mut JSRuntime, rp: *mut *mut JSString);

pub fn JS_RemoveObjectRootRT(rt: *mut JSRuntime, rp: *mut *mut JSObject);

pub fn js_AddRootRT(rt: *mut JSRuntime, vp: *mut JSVal, name: *c_char) -> JSBool;

pub fn js_AddGCThingRootRT(rt: *mut JSRuntime, rp: *mut *mut c_void, name: *c_char) -> JSBool;

pub fn js_RemoveRoot(rt: *mut JSRuntime, rp: *mut c_void);

pub fn JS_AnchorPtr(p: *mut c_void);

pub fn JS_MapGCRoots(rt: *mut JSRuntime, map: JSGCRootMapFun, data: *mut c_void) -> uint32_t;

pub fn JS_LockGCThing(cx: *mut JSContext, thing: *mut c_void) -> JSBool;

pub fn JS_LockGCThingRT(rt: *mut JSRuntime, thing: *mut c_void) -> JSBool;

pub fn JS_UnlockGCThing(cx: *mut JSContext, thing: *mut c_void) -> JSBool;

pub fn JS_UnlockGCThingRT(rt: *mut JSRuntime, thing: *mut c_void) -> JSBool;

pub fn JS_SetExtraGCRootsTracer(rt: *mut JSRuntime, traceOp: JSTraceDataOp, data: *mut c_void);

pub fn JS_CallTracer(trc: *mut JSTracer, thing: *mut c_void, kind: JSGCTraceKind);

pub fn JS_TracerInit(trc: *mut JSTracer, rt: *mut JSRuntime, callback: JSTraceCallback);

pub fn JS_TraceChildren(trc: *mut JSTracer, thing: *mut c_void, kind: JSGCTraceKind);

pub fn JS_TraceRuntime(trc: *mut JSTracer);

pub fn JS_GetTraceThingInfo(buf: *mut c_char, bufsize: size_t, trc: *mut JSTracer, thing: *mut c_void, kind: JSGCTraceKind, includeDetails: JSBool);

pub fn JS_GetTraceEdgeName(trc: *mut JSTracer, buffer: *mut c_char, bufferSize: c_int) -> *c_char;

pub fn JS_GC(rt: *mut JSRuntime);

pub fn JS_MaybeGC(cx: *mut JSContext);

pub fn JS_SetGCZeal(cx: *mut JSContext, zeal: uint8_t, frequency: uint32_t);

pub fn JS_InhibitGC(cx: *mut JSContext);

pub fn JS_AllowGC(cx: *mut JSContext);

pub fn JS_SetGCCallback(rt: *mut JSRuntime, cb: JSGCCallback);

pub fn JS_SetFinalizeCallback(rt: *mut JSRuntime, cb: JSFinalizeCallback);

pub fn JS_IsGCMarkingTracer(trc: *mut JSTracer) -> JSBool;

pub fn JS_IsAboutToBeFinalized(thing: *mut c_void) -> JSBool;

pub fn JS_SetGCParameter(rt: *mut JSRuntime, key: JSGCParamKey, value: uint32_t);

pub fn JS_GetGCParameter(rt: *mut JSRuntime, key: JSGCParamKey) -> uint32_t;

pub fn JS_SetGCParameterForThread(cx: *mut JSContext, key: JSGCParamKey, value: uint32_t);

pub fn JS_GetGCParameterForThread(cx: *mut JSContext, key: JSGCParamKey) -> uint32_t;

pub fn JS_NewExternalString(cx: *mut JSContext, chars: *jschar, length: size_t, fin: *JSStringFinalizer) -> *mut JSString;

pub fn JS_IsExternalString(str: *mut JSString) -> JSBool;

pub fn JS_GetExternalStringFinalizer(str: *mut JSString) -> *JSStringFinalizer;

pub fn JS_SetNativeStackQuota(cx: *mut JSRuntime, stackSize: size_t);

pub fn JS_IdArrayLength(cx: *mut JSContext, ida: *mut JSIdArray) -> c_int;

pub fn JS_IdArrayGet(cx: *mut JSContext, ida: *mut JSIdArray, index: c_int) -> jsid;

pub fn JS_DestroyIdArray(cx: *mut JSContext, ida: *mut JSIdArray);

pub fn JS_ValueToId(cx: *mut JSContext, v: JSVal, idp: *mut jsid) -> JSBool;

pub fn JS_IdToValue(cx: *mut JSContext, id: jsid, vp: *mut JSVal) -> JSBool;

pub fn JS_DefaultValue(cx: *mut JSContext, obj: *mut JSObject, hint: JSType, vp: *mut JSVal) -> JSBool;

pub fn JS_PropertyStub(cx: *mut JSContext, obj: JSHandleObject, id: JSHandleId, vp: JSMutableHandleValue) -> JSBool;

pub fn JS_StrictPropertyStub(cx: *mut JSContext, obj: JSHandleObject, id: JSHandleId, strict: JSBool, vp: JSMutableHandleValue) -> JSBool;

pub fn JS_EnumerateStub(cx: *mut JSContext, obj: JSHandleObject) -> JSBool;

pub fn JS_ResolveStub(cx: *mut JSContext, obj: JSHandleObject, id: JSHandleId) -> JSBool;

pub fn JS_ConvertStub(cx: *mut JSContext, obj: JSHandleObject, _type: JSType, vp: JSMutableHandleValue) -> JSBool;

pub fn JS_InitClass(cx: *mut JSContext, obj: *mut JSObject, parent_proto: *mut JSObject, clasp: *JSClass, constructor: JSNative, nargs: c_uint, ps: *JSPropertySpec, fs: *JSFunctionSpec, static_ps: *JSPropertySpec, static_fs: *JSFunctionSpec) -> *mut JSObject;

pub fn JS_LinkConstructorAndPrototype(cx: *mut JSContext, ctor: *mut JSObject, proto: *mut JSObject) -> JSBool;

pub fn JS_GetClass(obj: JSRawObject) -> *JSClass;

pub fn JS_InstanceOf(cx: *mut JSContext, obj: *mut JSObject, clasp: *JSClass, argv: *mut JSVal) -> JSBool;

pub fn JS_HasInstance(cx: *mut JSContext, obj: *mut JSObject, v: JSVal, bp: *mut JSBool) -> JSBool;

pub fn JS_GetPrivate(obj: JSRawObject) -> *mut c_void;

pub fn JS_SetPrivate(obj: JSRawObject, data: *mut c_void);

pub fn JS_GetInstancePrivate(cx: *mut JSContext, obj: *mut JSObject, clasp: *JSClass, argv: *mut JSVal) -> *mut c_void;

pub fn JS_GetPrototype(obj: JSRawObject) -> *mut JSObject;

pub fn JS_SetPrototype(cx: *mut JSContext, obj: *mut JSObject, proto: *mut JSObject) -> JSBool;

pub fn JS_GetParent(obj: JSRawObject) -> *mut JSObject;

pub fn JS_SetParent(cx: *mut JSContext, obj: *mut JSObject, parent: *mut JSObject) -> JSBool;

pub fn JS_GetConstructor(cx: *mut JSContext, proto: *mut JSObject) -> *mut JSObject;

pub fn JS_GetObjectId(cx: *mut JSContext, obj: JSRawObject, idp: *mut jsid) -> JSBool;

pub fn JS_NewGlobalObject(cx: *mut JSContext, clasp: *JSClass, principals: *mut JSPrincipals) -> *mut JSObject;

pub fn JS_NewObject(cx: *mut JSContext, clasp: *JSClass, proto: *mut JSObject, parent: *mut JSObject) -> *mut JSObject;

pub fn JS_IsExtensible(obj: JSRawObject) -> JSBool;

pub fn JS_IsNative(obj: JSRawObject) -> JSBool;

pub fn JS_GetObjectRuntime(obj: JSRawObject) -> *mut JSRuntime;

pub fn JS_NewObjectWithGivenProto(cx: *mut JSContext, clasp: *JSClass, proto: *mut JSObject, parent: *mut JSObject) -> *mut JSObject;

pub fn JS_DeepFreezeObject(cx: *mut JSContext, obj: *mut JSObject) -> JSBool;

pub fn JS_FreezeObject(cx: *mut JSContext, obj: *mut JSObject) -> JSBool;

pub fn JS_New(cx: *mut JSContext, ctor: *mut JSObject, argc: c_uint, argv: *mut JSVal) -> *mut JSObject;

pub fn JS_DefineObject(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, clasp: *JSClass, proto: *mut JSObject, attrs: c_uint) -> *mut JSObject;

pub fn JS_DefineConstDoubles(cx: *mut JSContext, obj: *mut JSObject, cds: *mut JSConstDoubleSpec) -> JSBool;

pub fn JS_DefineProperties(cx: *mut JSContext, obj: *mut JSObject, ps: *JSPropertySpec) -> JSBool;

pub fn JS_DefineProperty(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_DefinePropertyById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_DefineOwnProperty(cx: *mut JSContext, obj: *mut JSObject, id: jsid, descriptor: JSVal, bp: *mut JSBool) -> JSBool;

pub fn JS_GetPropertyAttributes(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, attrsp: *mut c_uint, foundp: *mut JSBool) -> JSBool;

pub fn JS_GetPropertyAttrsGetterAndSetter(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, attrsp: *mut c_uint, foundp: *mut JSBool, getterp: *mut JSPropertyOp, setterp: *mut JSStrictPropertyOp) -> JSBool;

pub fn JS_GetPropertyAttrsGetterAndSetterById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, attrsp: *mut c_uint, foundp: *mut JSBool, getterp: *mut JSPropertyOp, setterp: *mut JSStrictPropertyOp) -> JSBool;

pub fn JS_SetPropertyAttributes(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, attrs: c_uint, foundp: *mut JSBool) -> JSBool;

pub fn JS_DefinePropertyWithTinyId(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, tinyid: int8_t, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_AlreadyHasOwnProperty(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, foundp: *mut JSBool) -> JSBool;

pub fn JS_AlreadyHasOwnPropertyById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, foundp: *mut JSBool) -> JSBool;

pub fn JS_HasProperty(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, foundp: *mut JSBool) -> JSBool;

pub fn JS_HasPropertyById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, foundp: *mut JSBool) -> JSBool;

pub fn JS_LookupProperty(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, vp: *mut JSVal) -> JSBool;

pub fn JS_LookupPropertyById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, vp: *mut JSVal) -> JSBool;

pub fn JS_LookupPropertyWithFlags(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, flags: c_uint, vp: *mut JSVal) -> JSBool;

pub fn JS_LookupPropertyWithFlagsById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, flags: c_uint, objp: *mut *mut JSObject, vp: *mut JSVal) -> JSBool;

pub fn JS_GetPropertyDescriptorById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, flags: c_uint, desc: *mut JSPropertyDescriptor) -> JSBool;

pub fn JS_GetOwnPropertyDescriptor(cx: *mut JSContext, obj: *mut JSObject, id: jsid, vp: *mut JSVal) -> JSBool;

pub fn JS_GetProperty(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, vp: *mut JSVal) -> JSBool;

pub fn JS_GetPropertyDefault(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, def: JSVal, vp: *mut JSVal) -> JSBool;

pub fn JS_GetPropertyById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, vp: *mut JSVal) -> JSBool;

pub fn JS_GetPropertyByIdDefault(cx: *mut JSContext, obj: *mut JSObject, id: jsid, def: JSVal, vp: *mut JSVal) -> JSBool;

pub fn JS_ForwardGetPropertyTo(cx: *mut JSContext, obj: *mut JSObject, id: jsid, onBehalfOf: *mut JSObject, vp: *mut JSVal) -> JSBool;

pub fn JS_GetMethodById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, objp: *mut *mut JSObject, vp: *mut JSVal) -> JSBool;

pub fn JS_GetMethod(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, objp: *mut *mut JSObject, vp: *mut JSVal) -> JSBool;

pub fn JS_SetProperty(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, vp: *mut JSVal) -> JSBool;

pub fn JS_SetPropertyById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, vp: *mut JSVal) -> JSBool;

pub fn JS_DeleteProperty(cx: *mut JSContext, obj: *mut JSObject, name: *c_char) -> JSBool;

pub fn JS_DeleteProperty2(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, rval: *mut JSVal) -> JSBool;

pub fn JS_DeletePropertyById(cx: *mut JSContext, obj: *mut JSObject, id: jsid) -> JSBool;

pub fn JS_DeletePropertyById2(cx: *mut JSContext, obj: *mut JSObject, id: jsid, rval: *mut JSVal) -> JSBool;

pub fn JS_DefineUCProperty(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_GetUCPropertyAttributes(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, attrsp: *mut c_uint, foundp: *mut JSBool) -> JSBool;

pub fn JS_GetUCPropertyAttrsGetterAndSetter(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, attrsp: *mut c_uint, foundp: *mut JSBool, getterp: *mut JSPropertyOp, setterp: *mut JSStrictPropertyOp) -> JSBool;

pub fn JS_SetUCPropertyAttributes(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, attrs: c_uint, foundp: *mut JSBool) -> JSBool;

pub fn JS_DefineUCPropertyWithTinyId(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, tinyid: int8_t, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_AlreadyHasOwnUCProperty(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, foundp: *mut JSBool) -> JSBool;

pub fn JS_HasUCProperty(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, vp: *mut JSBool) -> JSBool;

pub fn JS_LookupUCProperty(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, vp: *mut JSVal) -> JSBool;

pub fn JS_GetUCProperty(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, vp: *mut JSVal) -> JSBool;

pub fn JS_SetUCProperty(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, vp: *mut JSVal) -> JSBool;

pub fn JS_DeleteUCProperty2(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, rval: *mut JSVal) -> JSBool;

pub fn JS_NewArrayObject(cx: *mut JSContext, length: c_int, vector: *mut JSVal) -> *mut JSObject;

pub fn JS_IsArrayObject(cx: *mut JSContext, obj: *mut JSObject) -> JSBool;

pub fn JS_GetArrayLength(cx: *mut JSContext, obj: *mut JSObject, lengthp: *mut uint32_t) -> JSBool;

pub fn JS_SetArrayLength(cx: *mut JSContext, obj: *mut JSObject, length: uint32_t) -> JSBool;

pub fn JS_DefineElement(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_AlreadyHasOwnElement(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t, foundp: *mut JSBool) -> JSBool;

pub fn JS_HasElement(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t, foundp: *mut JSBool) -> JSBool;

pub fn JS_LookupElement(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t, vp: *mut JSVal) -> JSBool;

pub fn JS_GetElement(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t, vp: *mut JSVal) -> JSBool;

pub fn JS_ForwardGetElementTo(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t, onBehalfOf: *mut JSObject, vp: *mut JSVal) -> JSBool;

pub fn JS_GetElementIfPresent(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t, onBehalfOf: *mut JSObject, vp: *mut JSVal, present: *mut JSBool) -> JSBool;

pub fn JS_SetElement(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t, vp: *mut JSVal) -> JSBool;

pub fn JS_DeleteElement(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t) -> JSBool;

pub fn JS_DeleteElement2(cx: *mut JSContext, obj: *mut JSObject, index: uint32_t, rval: *mut JSVal) -> JSBool;

pub fn JS_ClearScope(cx: *mut JSContext, obj: *mut JSObject);

pub fn JS_Enumerate(cx: *mut JSContext, obj: *mut JSObject) -> *mut JSIdArray;

pub fn JS_NewPropertyIterator(cx: *mut JSContext, obj: *mut JSObject) -> *mut JSObject;

pub fn JS_NextProperty(cx: *mut JSContext, iterobj: *mut JSObject, idp: *mut jsid) -> JSBool;

pub fn JS_ArrayIterator(cx: *mut JSContext, argc: c_uint, vp: *mut JSVal) -> JSBool;

pub fn JS_CheckAccess(cx: *mut JSContext, obj: *mut JSObject, id: jsid, mode: JSAccessMode, vp: *mut JSVal, attrsp: *mut c_uint) -> JSBool;

pub fn JS_GetReservedSlot(obj: JSRawObject, index: uint32_t) -> JSVal;

pub fn JS_SetReservedSlot(obj: JSRawObject, index: uint32_t, v: JSVal);

pub fn JS_HoldPrincipals(principals: *mut JSPrincipals);

pub fn JS_DropPrincipals(rt: *mut JSRuntime, principals: *mut JSPrincipals);

pub fn JS_SetSecurityCallbacks(rt: *mut JSRuntime, callbacks: *JSSecurityCallbacks);

pub fn JS_GetSecurityCallbacks(rt: *mut JSRuntime) -> *JSSecurityCallbacks;

pub fn JS_SetTrustedPrincipals(rt: *mut JSRuntime, prin: *mut JSPrincipals);

pub fn JS_InitDestroyPrincipalsCallback(rt: *mut JSRuntime, destroyPrincipals: JSDestroyPrincipalsOp);

pub fn JS_NewFunction(cx: *mut JSContext, call: JSNative, nargs: c_uint, flags: c_uint, parent: *mut JSObject, name: *c_char) -> *mut JSFunction;

pub fn JS_NewFunctionById(cx: *mut JSContext, call: JSNative, nargs: c_uint, flags: c_uint, parent: *mut JSObject, id: jsid) -> *mut JSFunction;

pub fn JS_GetFunctionObject(fun: *mut JSFunction) -> *mut JSObject;

pub fn JS_GetFunctionId(fun: *mut JSFunction) -> *mut JSString;

pub fn JS_GetFunctionDisplayId(fun: *mut JSFunction) -> *mut JSString;

pub fn JS_GetFunctionFlags(fun: *mut JSFunction) -> c_uint;

pub fn JS_GetFunctionArity(fun: *mut JSFunction) -> uint16_t;

pub fn JS_ObjectIsFunction(cx: *mut JSContext, obj: JSRawObject) -> JSBool;

pub fn JS_ObjectIsCallable(cx: *mut JSContext, obj: JSRawObject) -> JSBool;

pub fn JS_IsNativeFunction(funobj: JSRawObject, call: JSNative) -> JSBool;

pub fn JS_BindCallable(cx: *mut JSContext, callable: *mut JSObject, newThis: JSRawObject) -> *mut JSObject;

pub fn JS_DefineFunctions(cx: *mut JSContext, obj: *mut JSObject, fs: *JSFunctionSpec) -> JSBool;

pub fn JS_DefineFunction(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, call: JSNative, nargs: c_uint, attrs: c_uint) -> *mut JSFunction;

pub fn JS_DefineUCFunction(cx: *mut JSContext, obj: *mut JSObject, name: *jschar, namelen: size_t, call: JSNative, nargs: c_uint, attrs: c_uint) -> *mut JSFunction;

pub fn JS_DefineFunctionById(cx: *mut JSContext, obj: *mut JSObject, id: jsid, call: JSNative, nargs: c_uint, attrs: c_uint) -> *mut JSFunction;

pub fn JS_CloneFunctionObject(cx: *mut JSContext, funobj: *mut JSObject, parent: JSRawObject) -> *mut JSObject;

pub fn JS_BufferIsCompilableUnit(cx: *mut JSContext, bytes_are_utf8: JSBool, obj: *mut JSObject, bytes: *c_char, length: size_t) -> JSBool;

pub fn JS_CompileScript(cx: *mut JSContext, obj: *mut JSObject, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint) -> *mut JSScript;

pub fn JS_CompileScriptForPrincipals(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint) -> *mut JSScript;

pub fn JS_CompileScriptForPrincipalsVersion(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint, version: JSVersion) -> *mut JSScript;

pub fn JS_CompileUCScript(cx: *mut JSContext, obj: *mut JSObject, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint) -> *mut JSScript;

pub fn JS_CompileUCScriptForPrincipals(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint) -> *mut JSScript;

pub fn JS_CompileUCScriptForPrincipalsVersion(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint, version: JSVersion) -> *mut JSScript;

pub fn JS_CompileUCScriptForPrincipalsVersionOrigin(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, originPrincipals: *mut JSPrincipals, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint, version: JSVersion) -> *mut JSScript;

pub fn JS_CompileUTF8File(cx: *mut JSContext, obj: *mut JSObject, filename: *c_char) -> *mut JSScript;

pub fn JS_CompileUTF8FileHandle(cx: *mut JSContext, obj: *mut JSObject, filename: *c_char, fh: *mut FILE) -> *mut JSScript;

pub fn JS_CompileUTF8FileHandleForPrincipals(cx: *mut JSContext, obj: *mut JSObject, filename: *c_char, fh: *mut FILE, principals: *mut JSPrincipals) -> *mut JSScript;

pub fn JS_CompileUTF8FileHandleForPrincipalsVersion(cx: *mut JSContext, obj: *mut JSObject, filename: *c_char, fh: *mut FILE, principals: *mut JSPrincipals, version: JSVersion) -> *mut JSScript;

pub fn JS_GetGlobalFromScript(script: *mut JSScript) -> *mut JSObject;

pub fn JS_CompileFunction(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, nargs: c_uint, argnames: *mut *c_char, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint) -> *mut JSFunction;

pub fn JS_CompileFunctionForPrincipals(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, name: *c_char, nargs: c_uint, argnames: *mut *c_char, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint) -> *mut JSFunction;

pub fn JS_CompileUCFunction(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, nargs: c_uint, argnames: *mut *c_char, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint) -> *mut JSFunction;

pub fn JS_CompileUCFunctionForPrincipals(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, name: *c_char, nargs: c_uint, argnames: *mut *c_char, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint) -> *mut JSFunction;

pub fn JS_CompileUCFunctionForPrincipalsVersion(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, name: *c_char, nargs: c_uint, argnames: *mut *c_char, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint, version: JSVersion) -> *mut JSFunction;

pub fn JS_DecompileScript(cx: *mut JSContext, script: *mut JSScript, name: *c_char, indent: c_uint) -> *mut JSString;

pub fn JS_DecompileFunction(cx: *mut JSContext, fun: *mut JSFunction, indent: c_uint) -> *mut JSString;

pub fn JS_DecompileFunctionBody(cx: *mut JSContext, fun: *mut JSFunction, indent: c_uint) -> *mut JSString;

pub fn JS_ExecuteScript(cx: *mut JSContext, obj: *mut JSObject, script: *mut JSScript, rval: *mut JSVal) -> JSBool;

pub fn JS_ExecuteScriptVersion(cx: *mut JSContext, obj: *mut JSObject, script: *mut JSScript, rval: *mut JSVal, version: JSVersion) -> JSBool;

pub fn JS_EvaluateScript(cx: *mut JSContext, obj: *mut JSObject, bytes: *c_char, length: c_uint, filename: *c_char, lineno: c_uint, rval: *mut JSVal) -> JSBool;

pub fn JS_EvaluateScriptForPrincipals(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, bytes: *c_char, length: c_uint, filename: *c_char, lineno: c_uint, rval: *mut JSVal) -> JSBool;

pub fn JS_EvaluateScriptForPrincipalsVersion(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, bytes: *c_char, length: c_uint, filename: *c_char, lineno: c_uint, rval: *mut JSVal, version: JSVersion) -> JSBool;

pub fn JS_EvaluateUCScript(cx: *mut JSContext, obj: *mut JSObject, chars: *jschar, length: c_uint, filename: *c_char, lineno: c_uint, rval: *mut JSVal) -> JSBool;

pub fn JS_EvaluateUCScriptForPrincipals(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, chars: *jschar, length: c_uint, filename: *c_char, lineno: c_uint, rval: *mut JSVal) -> JSBool;

pub fn JS_EvaluateUCScriptForPrincipalsVersion(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, chars: *jschar, length: c_uint, filename: *c_char, lineno: c_uint, rval: *mut JSVal, version: JSVersion) -> JSBool;

pub fn JS_EvaluateUCScriptForPrincipalsVersionOrigin(cx: *mut JSContext, obj: *mut JSObject, principals: *mut JSPrincipals, originPrincipals: *mut JSPrincipals, chars: *jschar, length: c_uint, filename: *c_char, lineno: c_uint, rval: *mut JSVal, version: JSVersion) -> JSBool;

pub fn JS_CallFunction(cx: *mut JSContext, obj: *mut JSObject, fun: *mut JSFunction, argc: c_uint, argv: *mut JSVal, rval: *mut JSVal) -> JSBool;

pub fn JS_CallFunctionName(cx: *mut JSContext, obj: *mut JSObject, name: *c_char, argc: c_uint, argv: *mut JSVal, rval: *mut JSVal) -> JSBool;

pub fn JS_CallFunctionValue(cx: *mut JSContext, obj: *mut JSObject, fval: JSVal, argc: c_uint, argv: *mut JSVal, rval: *mut JSVal) -> JSBool;

pub fn JS_SetOperationCallback(cx: *mut JSContext, callback: JSOperationCallback) -> JSOperationCallback;

pub fn JS_GetOperationCallback(cx: *mut JSContext) -> JSOperationCallback;

pub fn JS_TriggerOperationCallback(rt: *mut JSRuntime);

pub fn JS_IsRunning(cx: *mut JSContext) -> JSBool;

pub fn JS_SaveFrameChain(cx: *mut JSContext) -> JSBool;

pub fn JS_RestoreFrameChain(cx: *mut JSContext);

pub fn JS_NewStringCopyN(cx: *mut JSContext, s: *c_char, n: size_t) -> *mut JSString;

pub fn JS_NewStringCopyZ(cx: *mut JSContext, s: *c_char) -> *mut JSString;

pub fn JS_InternJSString(cx: *mut JSContext, str: *mut JSString) -> *mut JSString;

pub fn JS_InternStringN(cx: *mut JSContext, s: *c_char, length: size_t) -> *mut JSString;

pub fn JS_InternString(cx: *mut JSContext, s: *c_char) -> *mut JSString;

pub fn JS_NewUCString(cx: *mut JSContext, chars: *mut jschar, length: size_t) -> *mut JSString;

pub fn JS_NewUCStringCopyN(cx: *mut JSContext, s: *jschar, n: size_t) -> *mut JSString;

pub fn JS_NewUCStringCopyZ(cx: *mut JSContext, s: *jschar) -> *mut JSString;

pub fn JS_InternUCStringN(cx: *mut JSContext, s: *jschar, length: size_t) -> *mut JSString;

pub fn JS_InternUCString(cx: *mut JSContext, s: *jschar) -> *mut JSString;

pub fn JS_CompareStrings(cx: *mut JSContext, str1: *mut JSString, str2: *mut JSString, result: *mut int32_t) -> JSBool;

pub fn JS_StringEqualsAscii(cx: *mut JSContext, str: *mut JSString, asciiBytes: *c_char, _match: *mut JSBool) -> JSBool;

pub fn JS_PutEscapedString(cx: *mut JSContext, buffer: *mut c_char, size: size_t, str: *mut JSString, quote: c_char) -> size_t;

pub fn JS_FileEscapedString(fp: *mut FILE, str: *mut JSString, quote: c_char) -> JSBool;

pub fn JS_GetStringLength(str: *mut JSString) -> size_t;

pub fn JS_GetStringCharsAndLength(cx: *mut JSContext, str: *mut JSString, length: *mut size_t) -> *jschar;

pub fn JS_GetInternedStringChars(str: *mut JSString) -> *jschar;

pub fn JS_GetInternedStringCharsAndLength(str: *mut JSString, length: *mut size_t) -> *jschar;

pub fn JS_GetStringCharsZ(cx: *mut JSContext, str: *mut JSString) -> *jschar;

pub fn JS_GetStringCharsZAndLength(cx: *mut JSContext, str: *mut JSString, length: *mut size_t) -> *jschar;

pub fn JS_FlattenString(cx: *mut JSContext, str: *mut JSString) -> *mut JSFlatString;

pub fn JS_GetFlatStringChars(str: *mut JSFlatString) -> *jschar;

pub fn JS_FlatStringEqualsAscii(str: *mut JSFlatString, asciiBytes: *c_char) -> JSBool;

pub fn JS_PutEscapedFlatString(buffer: *mut c_char, size: size_t, str: *mut JSFlatString, quote: c_char) -> size_t;

pub fn JS_NewGrowableString(cx: *mut JSContext, chars: *mut jschar, length: size_t) -> *mut JSString;

pub fn JS_NewDependentString(cx: *mut JSContext, str: *mut JSString, start: size_t, length: size_t) -> *mut JSString;

pub fn JS_ConcatStrings(cx: *mut JSContext, left: *mut JSString, right: *mut JSString) -> *mut JSString;

pub fn JS_UndependString(cx: *mut JSContext, str: *mut JSString) -> *jschar;

pub fn JS_MakeStringImmutable(cx: *mut JSContext, str: *mut JSString) -> JSBool;

pub fn JS_CStringsAreUTF8() -> JSBool;

pub fn JS_SetCStringsAreUTF8();

pub fn JS_EncodeCharacters(cx: *mut JSContext, src: *jschar, srclen: size_t, dst: *mut c_char, dstlenp: *mut size_t) -> JSBool;

pub fn JS_DecodeBytes(cx: *mut JSContext, src: *c_char, srclen: size_t, dst: *mut jschar, dstlenp: *mut size_t) -> JSBool;

pub fn JS_DecodeUTF8(cx: *mut JSContext, src: *c_char, srclen: size_t, dst: *mut jschar, dstlenp: *mut size_t) -> JSBool;

pub fn JS_EncodeString(cx: *mut JSContext, str: *mut JSString) -> *mut c_char;

pub fn JS_GetStringEncodingLength(cx: *mut JSContext, str: *mut JSString) -> size_t;

pub fn JS_EncodeStringToBuffer(str: *mut JSString, buffer: *mut c_char, length: size_t) -> size_t;

pub fn JS_Stringify(cx: *mut JSContext, vp: *mut JSVal, replacer: *mut JSObject, space: JSVal, callback: JSONWriteCallback, data: *mut c_void) -> JSBool;

pub fn JS_ParseJSON(cx: *mut JSContext, chars: *jschar, len: uint32_t, vp: *mut JSVal) -> JSBool;

pub fn JS_ParseJSONWithReviver(cx: *mut JSContext, chars: *jschar, len: uint32_t, reviver: JSVal, vp: *mut JSVal) -> JSBool;

pub fn JS_ReadStructuredClone(cx: *mut JSContext, data: *uint64_t, nbytes: size_t, version: uint32_t, vp: *mut JSVal, optionalCallbacks: *JSStructuredCloneCallbacks, closure: *mut c_void) -> JSBool;

pub fn JS_WriteStructuredClone(cx: *mut JSContext, v: JSVal, datap: *mut *mut uint64_t, nbytesp: *mut size_t, optionalCallbacks: *JSStructuredCloneCallbacks, closure: *mut c_void) -> JSBool;

pub fn JS_StructuredClone(cx: *mut JSContext, v: JSVal, vp: *mut JSVal, optionalCallbacks: *JSStructuredCloneCallbacks, closure: *mut c_void) -> JSBool;

pub fn JS_SetStructuredCloneCallbacks(rt: *mut JSRuntime, callbacks: *JSStructuredCloneCallbacks);

pub fn JS_ReadUint32Pair(r: *mut JSStructuredCloneReader, p1: *mut uint32_t, p2: *mut uint32_t) -> JSBool;

pub fn JS_ReadBytes(r: *mut JSStructuredCloneReader, p: *mut c_void, len: size_t) -> JSBool;

pub fn JS_ReadTypedArray(r: *mut JSStructuredCloneReader, vp: *mut JSVal) -> JSBool;

pub fn JS_WriteUint32Pair(w: *mut JSStructuredCloneWriter, tag: uint32_t, data: uint32_t) -> JSBool;

pub fn JS_WriteBytes(w: *mut JSStructuredCloneWriter, p: *c_void, len: size_t) -> JSBool;

pub fn JS_WriteTypedArray(w: *mut JSStructuredCloneWriter, v: JSVal) -> JSBool;

pub fn JS_SetLocaleCallbacks(cx: *mut JSContext, callbacks: *mut JSLocaleCallbacks);

pub fn JS_GetLocaleCallbacks(cx: *mut JSContext) -> *mut JSLocaleCallbacks;

pub fn JS_ReportError(cx: *mut JSContext, format: *c_char, ...);

pub fn JS_ReportErrorNumber(cx: *mut JSContext, errorCallback: JSErrorCallback, userRef: *mut c_void, errorNumber: c_uint, ...);

pub fn JS_ReportErrorNumberUC(cx: *mut JSContext, errorCallback: JSErrorCallback, userRef: *mut c_void, errorNumber: c_uint, ...);

pub fn JS_ReportWarning(cx: *mut JSContext, format: *c_char, ...) -> JSBool;

pub fn JS_ReportErrorFlagsAndNumber(cx: *mut JSContext, flags: c_uint, errorCallback: JSErrorCallback, userRef: *mut c_void, errorNumber: c_uint, ...) -> JSBool;

pub fn JS_ReportErrorFlagsAndNumberUC(cx: *mut JSContext, flags: c_uint, errorCallback: JSErrorCallback, userRef: *mut c_void, errorNumber: c_uint, ...) -> JSBool;

pub fn JS_ReportOutOfMemory(cx: *mut JSContext);

pub fn JS_ReportAllocationOverflow(cx: *mut JSContext);

pub fn JS_GetErrorReporter(cx: *mut JSContext) -> JSErrorReporter;

pub fn JS_SetErrorReporter(cx: *mut JSContext, er: JSErrorReporter) -> JSErrorReporter;

pub fn JS_NewDateObject(cx: *mut JSContext, year: c_int, mon: c_int, mday: c_int, hour: c_int, min: c_int, sec: c_int) -> *mut JSObject;

pub fn JS_NewDateObjectMsec(cx: *mut JSContext, msec: c_double) -> *mut JSObject;

pub fn JS_ObjectIsDate(cx: *mut JSContext, obj: JSRawObject) -> JSBool;

pub fn JS_ClearDateCaches(cx: *mut JSContext);

pub fn JS_NewRegExpObject(cx: *mut JSContext, obj: *mut JSObject, bytes: *mut c_char, length: size_t, flags: c_uint) -> *mut JSObject;

pub fn JS_NewUCRegExpObject(cx: *mut JSContext, obj: *mut JSObject, chars: *mut jschar, length: size_t, flags: c_uint) -> *mut JSObject;

pub fn JS_SetRegExpInput(cx: *mut JSContext, obj: *mut JSObject, input: *mut JSString, multiline: JSBool);

pub fn JS_ClearRegExpStatics(cx: *mut JSContext, obj: *mut JSObject);

pub fn JS_ExecuteRegExp(cx: *mut JSContext, obj: *mut JSObject, reobj: *mut JSObject, chars: *mut jschar, length: size_t, indexp: *mut size_t, test: JSBool, rval: *mut JSVal) -> JSBool;

pub fn JS_NewRegExpObjectNoStatics(cx: *mut JSContext, bytes: *mut c_char, length: size_t, flags: c_uint) -> *mut JSObject;

pub fn JS_NewUCRegExpObjectNoStatics(cx: *mut JSContext, chars: *mut jschar, length: size_t, flags: c_uint) -> *mut JSObject;

pub fn JS_ExecuteRegExpNoStatics(cx: *mut JSContext, reobj: *mut JSObject, chars: *mut jschar, length: size_t, indexp: *mut size_t, test: JSBool, rval: *mut JSVal) -> JSBool;

pub fn JS_ObjectIsRegExp(cx: *mut JSContext, obj: *mut JSObject) -> JSBool;

pub fn JS_GetRegExpFlags(cx: *mut JSContext, obj: *mut JSObject) -> c_uint;

pub fn JS_GetRegExpSource(cx: *mut JSContext, obj: *mut JSObject) -> *mut JSString;

pub fn JS_IsExceptionPending(cx: *mut JSContext) -> JSBool;

pub fn JS_GetPendingException(cx: *mut JSContext, vp: *mut JSVal) -> JSBool;

pub fn JS_SetPendingException(cx: *mut JSContext, v: JSVal);

pub fn JS_ClearPendingException(cx: *mut JSContext);

pub fn JS_ReportPendingException(cx: *mut JSContext) -> JSBool;

pub fn JS_SaveExceptionState(cx: *mut JSContext) -> *mut JSExceptionState;

pub fn JS_RestoreExceptionState(cx: *mut JSContext, state: *mut JSExceptionState);

pub fn JS_DropExceptionState(cx: *mut JSContext, state: *mut JSExceptionState);

pub fn JS_ErrorFromException(cx: *mut JSContext, v: JSVal) -> *mut JSErrorReport;

pub fn JS_ThrowReportedError(cx: *mut JSContext, message: *c_char, reportp: *mut JSErrorReport) -> JSBool;

pub fn JS_ThrowStopIteration(cx: *mut JSContext) -> JSBool;

pub fn JS_GetCurrentThread() -> intptr_t;

pub fn JS_AbortIfWrongThread(rt: *mut JSRuntime);

pub fn JS_ClearRuntimeThread(rt: *mut JSRuntime);

pub fn JS_SetRuntimeThread(rt: *mut JSRuntime);

pub fn JS_SetNativeStackBounds(rt: *mut JSRuntime, minValue: uintptr_t, maxValue: uintptr_t);

pub fn JS_NewObjectForConstructor(cx: *mut JSContext, clasp: *JSClass, vp: *JSVal) -> *mut JSObject;

pub fn JS_IndexToId(cx: *mut JSContext, index: uint32_t, id: *mut jsid) -> JSBool;

pub fn JS_IsIdentifier(cx: *mut JSContext, str: *mut JSString, isIdentifier: *mut JSBool) -> JSBool;

pub fn JS_DescribeScriptedCaller(cx: *mut JSContext, script: *mut *mut JSScript, lineno: *mut c_uint) -> JSBool;

pub fn JS_EncodeScript(cx: *mut JSContext, script: *mut JSScript, lengthp: *mut uint32_t) -> *mut c_void;

pub fn JS_EncodeInterpretedFunction(cx: *mut JSContext, funobj: JSRawObject, lengthp: *mut uint32_t) -> *mut c_void;

pub fn JS_DecodeScript(cx: *mut JSContext, data: *c_void, length: uint32_t, principals: *mut JSPrincipals, originPrincipals: *mut JSPrincipals) -> *mut JSScript;

pub fn JS_DecodeInterpretedFunction(cx: *mut JSContext, data: *c_void, length: uint32_t, principals: *mut JSPrincipals, originPrincipals: *mut JSPrincipals) -> *mut JSObject;
}
